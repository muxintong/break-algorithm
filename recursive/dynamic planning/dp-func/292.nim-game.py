"""
你和你的朋友面前有一堆石子，你们轮流拿，一次至少拿一颗，最多拿三颗，谁拿走最后一颗石子谁获胜。
假设你们都很聪明，由你第一个开始拿，请你写一个算法，输入一个正整数 n，返回你是否能赢（true 或 false）。

比如现在有 4 颗石子，算法应该返回 false。因为无论你拿 1颗 2颗还是 3颗，对方都能一次性拿完，拿走最后一颗石子，所以你一定会输。
首先，这道题肯定可以使用动态规划，因为显然原问题存在子问题，且子问题存在重复。
但是因为你们都很聪明，涉及到你和对手的博弈，动态规划会比较复杂。

我们解决这种问题的思路一般都是反着思考：
如果我能赢，那么最后轮到我取石子的时候必须要剩下 1~3 颗石子，这样我才能一把拿完。
如何营造这样的一个局面呢？显然，如果对手拿的时候只剩 4 颗石子，那么无论他怎么拿，总会剩下 1~3 颗石子，我就能赢。
如何逼迫对手面对 4 颗石子呢？要想办法，让我选择的时候还有 5~7 颗石子，这样的话我就有把握让对方不得不面对 4 颗石子。
如何营造 5~7 颗石子的局面呢？让对手面对 8 颗石子，无论他怎么拿，都会给我剩下 5~7 颗，我就能赢。

这样一直循环下去，我们发现只要踩到 4 的倍数，就落入了圈套，永远逃不出 4 的倍数，而且一定会输。所以这道题的解法非常简单：
"""


class Solution:
    def canWinNim(self, n: int) -> bool:
        return n % 4 != 0


def main():
    # 输入：n = 4
    # 输出：false
    # 解释：以下是可能的结果:
    # 1. 移除1颗石头。你的朋友移走了3块石头，包括最后一块。你的朋友赢了。
    # 2. 移除2个石子。你的朋友移走2块石头，包括最后一块。你的朋友赢了。
    # 3.你移走3颗石子。你的朋友移走了最后一块石头。你的朋友赢了。
    # 在所有结果中，你的朋友是赢家。
    solution1 = Solution()
    print(solution1.canWinNim(n=4))

    # 输入：n = 1
    # 输出：true输
    solution2 = Solution()
    print(solution2.canWinNim(n=1))

    # 输入：n = 2
    # 输出：true
    solution3 = Solution()
    print(solution3.canWinNim(n=2))


if __name__ == '__main__':
    main()
