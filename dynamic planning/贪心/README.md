# [贪心](https://labuladong.github.io/algo/3/29/99/)
</br>贪心可认为是动规算法的特例，相比动规，贪心需满足更多的条件（贪心选择性质），但效率比动规更高。
</br>使用暴力：指数级时间。
</br>使用动规：消除重叠子问题，可降低到多项式级别的时间。
</br>若满足贪心选择性质：可进一步降低时间复制度，达到线性级别。
</br>
</br>贪心选择性质：每一步都做出一个局部最优选择，最终的结果就是全局最优。
</br>NOTE：该性质特殊，只有部分问题拥有这个性质，大部分问题不具有贪心选择性质。
</br>

---

## [435.无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)
</br>给你多个形如[start,end]的闭区间，算出这些区间中最多有几个互不相交的区间。
```java
 int intervalSchedule(int[][] intvs);
```
</br>例：intvs = [[1,3], [2,4], [3,6]]， 这些区间最多有 2 个区间互不相交，即 [[1,3], [3,6]]， 你的算法应该返回 2。
</br>**注意边界相同并不算相交。**
</br>
</br>这个问题在生活中的应用广泛，比如你今天有好几个活动，每个活动都可以用区间 [start, end] 表示开始和结束的时间，请问你今天最多能参加几个活动？
</br>显然你一个人不能同时参加两个活动，所以说这个问题就是求这些时间区间的最大不相交子集。
</br>
</br>这个问题有许多看起来不错的贪心思路，却都不能得到正确答案。比如说：
</br>也许我们可以每次选择可选区间中开始最早的那个？但是可能存在某些区间开始很早，但是很长，使得我们错误地错过了一些短的区间。
</br>或者我们每次选择可选区间中最短的那个？
</br>或者选择出现冲突最少的那个区间？
</br>这些方案都能很容易举出反例，不是正确的方案。
</br>
</br>正确的思路其实很简单，可以分为以下三步：
</br>1、从区间集合 intvs 中选择一个区间 x，这个 x 是在当前所有区间中结束最早的（end 最小）。
</br>2、把所有与 x 区间相交的区间从区间集合 intvs 中删除。
</br>3、重复步骤 1 和 2，直到 intvs 为空为止。之前选出的那些 x 就是最大不相交子集。
</br>把这个思路实现成算法的话，可以按每个区间的 end 数值升序排序，因为这样处理之后实现步骤 1 和步骤 2 都方便很多。
算法实现：
对于步骤1：由于事先按照每个区间的end数值升序排序，所以最小的end即为第一个元素。
关键：如何移除与x相交的区间，选择下一轮循环的x。
由于事先按照每个区间的end升序排序，故所有与x相交的区间必然会与x的end相交；
如果一个区间不想与x的end相交，它的start必然要大于等于x的end：


